<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Audio Guide Prompt to Voice with Highlight</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; max-width: 760px; margin: 2rem auto; line-height: 1.45; }
  label { display:block; margin-top:1rem; font-weight:600; }
  textarea, input, select { width: 100%; padding: .6rem; margin-top: .25rem; border: 1px solid #ddd; border-radius: .5rem; }
  button { margin-top: 1rem; padding: .8rem 1rem; font-size: 1rem; border-radius: .6rem; border: 1px solid #ddd; cursor: pointer; }
  audio { display:block; margin-top: 1rem; width: 100%; }
  #outputText { margin-top: .75rem; background: #f7f7f8; padding: 1rem; border-radius: .6rem; }
  #outputText span { transition: background-color .18s ease, color .18s ease; }
  #outputText span.current { background: #fff1b8; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
  .muted { color: #666; font-size: .9rem; }
  .small { font-size: .9rem; }
</style>
</head>
<body>
<h1>Audio Guide Prompt to Voice</h1>

<label>OpenAI API Key
  <input id="apiKey" type="password" placeholder="sk-..." />
</label>

<div class="row">
  <div>
    <label>Text model for script
      <select id="textModel">
        <option value="gpt-4o-mini" selected>gpt-4o-mini</option>
        <option value="gpt-5-nano">gpt-5-nano</option>
        <option value="gpt-4o">gpt-4o</option>
      </select>
    </label>
  </div>
  <div>
    <label>TTS model for voice
      <select id="ttsModel">
        <option value="gpt-4o-mini-tts" selected>gpt-4o-mini-tts</option>
        <option value="tts-1-hd">tts-1-hd</option>
        <option value="tts-1">tts-1</option>
      </select>
    </label>
  </div>
</div>

<div class="row">
  <div>
    <label>Voice
      <select id="voice">
        <option value="alloy" selected>alloy</option>
        <option value="verse">verse</option>
        <option value="sage">sage</option>
        <option value="aria">aria</option>
      </select>
    </label>
  </div>
  <div>
    <label>Audio format
      <select id="audioFormat">
        <option value="mp3" selected>mp3</option>
        <option value="wav">wav</option>
        <option value="ogg">ogg</option>
      </select>
    </label>
  </div>
</div>

<label>Attraction Name
  <input id="attractionName" type="text" placeholder="Eiffel Tower" />
</label>

<label>Attraction Address
  <input id="attractionAddress" type="text" placeholder="Paris, France" />
</label>

<div class="row">
  <div>
    <label>User Latitude
      <input id="lat" type="number" step="any" placeholder="48.8584" />
    </label>
  </div>
  <div>
    <label>User Longitude
      <input id="lng" type="number" step="any" placeholder="2.2945" />
    </label>
  </div>
</div>

<div class="row">
  <div>
    <label>Theme
      <input id="theme" type="text" placeholder="architecture, history, art..." />
    </label>
  </div>
  <div>
    <label>Audio Length
      <select id="audioLength">
        <option value="short">Short about 100 words</option>
        <option value="medium" selected>Medium about 250 words</option>
        <option value="long">Long 500 plus words</option>
      </select>
    </label>
  </div>
</div>

<button id="run">Generate Narration</button>

<h2>Generated Script</h2>
<div id="outputText" class="small">Your narration will appear here</div>

<h2>Audio</h2>
<audio id="player" controls></audio>
<p class="muted small">Highlight is approximate. It divides the total audio duration across sentences by relative length. Playback speed changes are handled.</p>

<script>
function generatePrompt(attractionName, attractionAddress, userLocation, preferences = {}) {
  const theme = preferences.theme || "local history";
  const length = preferences.audioLength || "medium";

  const lengthText =
    length === "short" ? "around 100 words"
    : length === "long" ? "about 500 words in a detailed but friendly way"
    : "about 250 words";

  const safeName = attractionName || "this spot";
  const safeAddress = attractionAddress || "";
  const addressLine = safeAddress ? `It is located at ${safeAddress}. ` : "";

  return `
You are an engaging and friendly expert tour guide who specializes in ${theme}. Speak as if you are chatting with a curious visitor right next to you. Keep it natural, warm, and human. Aim for ${lengthText}.

Do not mention GPS coordinates or repeat greetings. Do not invent facts. If you are not sure about something, say "I cannot verify this." Label any unverified rumors or conflicting accounts as [Unverified]. Never present generated or inferred content as fact.

Context for you
• Attraction name: "${safeName}"
• ${addressLine}Avoid giving precise directions based on coordinates. Offer general orientation only if commonly known and verifiable.

What to cover
1) Start with one inviting line that says what makes "${safeName}" special. If you lack specifics, keep it general and welcoming.
2) Share one to three interesting historical or cultural insights tied to ${theme}. Prefer vivid but accurate details. If details are missing say "I do not have access to that information."
3) If there are genuine bits of gossip or lore, include one short item and label it [Unverified] unless it is well sourced.
4) Explain why this place matters from a ${theme} perspective using known facts. If unsure, say it is your general perspective and keep it high level.
5) Give one practical insider tip that could realistically improve the visit. If you do not have a specific tip, offer a helpful general suggestion.

Style
• Sound conversational, not scripted. Use plain language and vary sentence length.
• Prefer concrete sensory hints. Help the listener imagine what they might see or feel without overdoing it.
• Keep names and dates accurate. If you cannot confirm a detail, say so clearly.
• End with a single sentence that invites the listener to look for one small detail on site.

Now write the audio guide for "${safeName}".`;
}

/* Split text into sentences and preserve punctuation */
function splitIntoSentences(text) {
  const cleaned = text.replace(/\s+/g, " ").trim();
  if (!cleaned) return [];
  const parts = cleaned.match(/[^.!?]+[.!?]?/g) || [cleaned];
  return parts.map(s => s.trim()).filter(Boolean);
}

/* Render sentences as spans and return references */
function renderSentences(container, sentences) {
  container.innerHTML = "";
  const spans = sentences.map((s, i) => {
    const span = document.createElement("span");
    span.textContent = s + " ";
    span.dataset.index = String(i);
    container.appendChild(span);
    return span;
  });
  return spans;
}

/* Build a timing map by distributing total audio duration proportionally by sentence length */
function buildTiming(sentences, totalSeconds) {
  const lengths = sentences.map(s => Math.max(1, s.length));
  const totalLen = lengths.reduce((a, b) => a + b, 0);
  let t = 0;
  return sentences.map((s, i) => {
    const share = lengths[i] / totalLen;
    const dur = totalSeconds * share;
    const start = t;
    const end = t + dur;
    t = end;
    return { i, start, end };
  });
}

/* Robust text extraction across API shapes */
function extractText(data) {
  try {
    if (data && typeof data.output_text === "string" && data.output_text.trim()) {
      return data.output_text.trim();
    }
    if (Array.isArray(data?.output)) {
      for (const block of data.output) {
        const content = block?.content;
        if (Array.isArray(content)) {
          for (const c of content) {
            if (c?.type === "output_text" && typeof c.text === "string") return c.text.trim();
            if (c?.type === "text" && typeof c.text === "string") return c.text.trim();
            if (c?.type === "message" && c.message?.content) {
              const mc = c.message.content;
              if (Array.isArray(mc)) {
                const t = mc.find(x => x.type === "text")?.text;
                if (typeof t === "string") return t.trim();
              }
              if (typeof mc === "string") return mc.trim();
            }
          }
        }
      }
    }
    if (Array.isArray(data?.choices) && data.choices[0]?.message?.content) {
      return String(data.choices[0].message.content).trim();
    }
  } catch (e) {}
  return "";
}

/* UI wiring */
const outputEl = document.getElementById("outputText");
const player = document.getElementById("player");

let spans = [];
let timeline = [];
let lastActive = -1;

/* Update highlight based on audio time and playbackRate */
function updateHighlight() {
  if (!timeline.length) return;
  const rate = player.playbackRate || 1;
  const t = player.currentTime * rate; // adjust for speed changes
  const idx = timeline.findIndex(seg => t >= seg.start && t < seg.end);
  const active = idx === -1 && t >= (timeline.at(-1)?.end || Infinity) ? timeline.length - 1 : idx;
  if (active !== -1 && active !== lastActive) {
    if (lastActive >= 0 && spans[lastActive]) spans[lastActive].classList.remove("current");
    if (spans[active]) {
      spans[active].classList.add("current");
      spans[active].scrollIntoView({ block: "nearest", behavior: "smooth" });
    }
    lastActive = active;
  }
  if (!player.paused) requestAnimationFrame(updateHighlight);
}

/* Generate and play */
document.getElementById("run").addEventListener("click", async () => {
  const key = document.getElementById("apiKey").value.trim();
  const textModel = document.getElementById("textModel").value;
  const ttsModel = document.getElementById("ttsModel").value;
  const voice = document.getElementById("voice").value;
  const audioFormat = document.getElementById("audioFormat").value;

  const attractionName = document.getElementById("attractionName").value.trim();
  const attractionAddress = document.getElementById("attractionAddress").value.trim();
  const lat = parseFloat(document.getElementById("lat").value);
  const lng = parseFloat(document.getElementById("lng").value);
  const theme = document.getElementById("theme").value.trim();
  const audioLength = document.getElementById("audioLength").value;

  outputEl.textContent = "Loading...";
  player.src = "";
  spans = [];
  timeline = [];
  lastActive = -1;

  if (!key) {
    alert("Please enter your OpenAI API key");
    return;
  }

  const prompt = generatePrompt(
    attractionName,
    attractionAddress,
    { lat, lng },
    { theme, audioLength }
  );

  try {
    // Step 1 get text
    const textResp = await fetch("https://api.openai.com/v1/responses", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
      body: JSON.stringify({ model: textModel, input: prompt })
    });

    let narration = "";
    if (textResp.ok) {
      const textData = await textResp.json();
      narration = extractText(textData);
    }
    if (!narration) {
      const chatResp = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
        body: JSON.stringify({ model: textModel, messages: [{ role: "user", content: prompt }] })
      });
      const chatData = await chatResp.json();
      narration = extractText(chatData);
    }

    if (!narration) {
      outputEl.textContent = "[No text returned]";
      return;
    }

    const sentences = splitIntoSentences(narration);
    spans = renderSentences(outputEl, sentences);

    // Step 2 synthesize audio
    const ttsResp = await fetch("https://api.openai.com/v1/audio/speech", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
      body: JSON.stringify({ model: ttsModel, voice, input: narration, format: audioFormat })
    });
    if (!ttsResp.ok) {
      outputEl.innerHTML += "<br><br><em class='muted'>TTS error. Check console.</em>";
      console.error(await ttsResp.text());
      return;
    }

    const mime =
      audioFormat === "wav" ? "audio/wav" :
      audioFormat === "ogg" ? "audio/ogg" :
      "audio/mpeg";

    const buf = await ttsResp.arrayBuffer();
    const blob = new Blob([buf], { type: mime });
    const url = URL.createObjectURL(blob);
    player.src = url;

    // Build timing map after metadata loads
    player.onloadedmetadata = () => {
      const total = player.duration || 1;
      timeline = buildTiming(sentences, total);
      lastActive = -1;
    };

    player.onplay = () => requestAnimationFrame(updateHighlight);
    player.onpause = () => {}; // stop loop naturally
    player.onseeked = () => { lastActive = -1; requestAnimationFrame(updateHighlight); };
    player.onratechange = () => { lastActive = -1; requestAnimationFrame(updateHighlight); };
    player.onended = () => { if (lastActive >= 0 && spans[lastActive]) spans[lastActive].classList.remove("current"); };
  } catch (err) {
    console.error(err);
    outputEl.textContent = "Error: " + err.message;
  }
});
</script>
</body>
</html>
