// Gemini Provider Implementation
// Uses Gemini 2.5 Flash Native Audio Preview for simultaneous text + audio generation

import { generatePrompt } from '../../promptGenerator.ts';
import type { AttractionPreferences, AttractionTheme, SupportedLanguage } from '../../promptGenerator.ts';
import {
  IAIProvider,
  AIGenerationOptions,
  AudioGenerationOptions,
  AIGenerationResult,
  AudioGenerationResult,
  SimultaneousGenerationResult,
} from '../../types/aiProvider.ts';
import { processPcmToBase64Wav } from '../../audio/AudioProcessor.ts';
import { GeminiLiveClient } from './GeminiLiveClient.ts';

export class GeminiProvider implements IAIProvider {
  constructor(private apiKey: string) {}

  private static readonly allowedThemes: AttractionTheme[] = ['history', 'nature', 'architecture', 'culture', 'general'];
  private static readonly allowedAudioLengths = ['short', 'medium', 'deep-dive'] as const;
  private static readonly allowedLanguages: SupportedLanguage[] = ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh'];

  private static getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    try {
      return JSON.stringify(error);
    } catch {
      return 'Unknown error';
    }
  }

  getProviderName(): string {
    return 'Gemini';
  }

  supportsSimultaneousGeneration(): boolean {
    return true; // Gemini can generate text and audio in one API call
  }

  /**
   * Generate narrative content only (text-only mode)
   */
  async generateContent(options: AIGenerationOptions): Promise<AIGenerationResult> {
    console.log('[Gemini] Generating text-only content');

    const normalizedPreferences = this.sanitizePreferences(options.preferences);
    const systemPrompt = this.buildSystemPrompt(normalizedPreferences);
    const userPrompt = generatePrompt(
      options.attractionName,
      options.attractionAddress || '',
      options.userLocation,
      normalizedPreferences,
      options.poiLocation,
      options.spatialHints,
      options.situationalContext,
      options.wikipediaData
    );

    try {
      // Use Gemini REST API for text-only generation
      const content = await this.generateTextOnly(systemPrompt, userPrompt);

      return {
        content,
        modelUsed: 'gemini-2.5-flash-preview',
      };
    } catch (error: unknown) {
      console.error('[Gemini] Text generation failed:', error);
      throw new Error(`Gemini text generation failed: ${GeminiProvider.getErrorMessage(error)}`);
    }
  }

  /**
   * Generate audio from text (audio-only mode)
   * Note: This is less efficient than simultaneous generation
   */
  async generateAudio(
    text: string,
    options: AudioGenerationOptions
  ): Promise<AudioGenerationResult> {
    console.log('[Gemini] Generating audio-only (inefficient, prefer simultaneous)');

    const systemPrompt = this.buildSystemPrompt({
      language: options.language,
    });

    try {
      const client = new GeminiLiveClient({
        apiKey: this.apiKey,
        model: 'gemini-2.5-flash-preview-native-audio',
        systemPrompt,
        userPrompt: `Please read this text aloud: ${text}`,
      });

      const { audioChunks } = await client.generateContentAndAudio();

      if (audioChunks.length === 0) {
        throw new Error('No audio generated by Gemini');
      }

      const { audioData, audioBase64 } = processPcmToBase64Wav(audioChunks, 16000, 1);

      return {
        audioData,
        audioBase64,
        format: 'wav',
        voiceUsed: 'Puck',
        modelUsed: 'gemini-2.5-flash-preview-native-audio',
      };
    } catch (error: unknown) {
      console.error('[Gemini] Audio generation failed:', error);
      throw new Error(`Gemini audio generation failed: ${GeminiProvider.getErrorMessage(error)}`);
    }
  }

  /**
   * Generate content and audio simultaneously (primary Gemini use case)
   */
  async generateSimultaneous(
    options: AIGenerationOptions & AudioGenerationOptions
  ): Promise<SimultaneousGenerationResult> {
    console.log('[Gemini] Generating content and audio simultaneously');

    const normalizedPreferences = this.sanitizePreferences(options.preferences);
    const systemPrompt = this.buildSystemPrompt(normalizedPreferences);
    const userPrompt = generatePrompt(
      options.attractionName,
      options.attractionAddress || '',
      options.userLocation,
      normalizedPreferences,
      options.poiLocation,
      options.spatialHints,
      options.situationalContext,
      options.wikipediaData
    );

    try {
      const client = new GeminiLiveClient({
        apiKey: this.apiKey,
        model: 'gemini-2.5-flash-preview-native-audio',
        systemPrompt,
        userPrompt,
      });

      const { text, audioChunks } = await client.generateContentAndAudio();

      if (!text || text.length === 0) {
        throw new Error('No text content generated by Gemini');
      }

      if (audioChunks.length === 0) {
        throw new Error('No audio generated by Gemini');
      }

      const { audioData, audioBase64 } = processPcmToBase64Wav(audioChunks, 16000, 1);

      console.log('[Gemini] Successfully generated text and audio:', {
        textLength: text.length,
        audioChunks: audioChunks.length,
        audioSize: audioData.byteLength,
      });

      return {
        content: text,
        audioData,
        audioBase64,
        format: 'wav',
        modelUsed: 'gemini-2.5-flash-preview-native-audio',
        voiceUsed: 'Puck',
      };
    } catch (error: unknown) {
      console.error('[Gemini] Simultaneous generation failed:', error);
      throw new Error(`Gemini simultaneous generation failed: ${GeminiProvider.getErrorMessage(error)}`);
    }
  }

  // Private methods

  /**
   * Build minimal system prompt for Gemini
   * Most instructions are now in promptGenerator.ts modular blocks
   */
  private buildSystemPrompt(preferences?: AttractionPreferences): string {
    return `You are a professional tour guide. Follow all instructions provided precisely, maintaining the voice and structure specified.`;
  }

  /**
   * Generate text-only using Gemini REST API (fallback method)
   */
  private async generateTextOnly(systemPrompt: string, userPrompt: string): Promise<string> {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview:generateContent?key=${this.apiKey}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: userPrompt,
              },
            ],
          },
        ],
        systemInstruction: {
          parts: [
            {
              text: systemPrompt,
            },
          ],
        },
        generationConfig: {
          temperature: 0.9,
          maxOutputTokens: 800,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Gemini API error: ${errorText}`);
    }

    const data = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No candidates returned from Gemini');
    }

    const candidate = data.candidates[0];
    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
      throw new Error('No content parts in Gemini response');
    }

    return candidate.content.parts[0].text;
  }

  private sanitizePreferences(preferences?: AttractionPreferences | {
    theme?: string;
    audioLength?: 'short' | 'medium' | 'deep-dive';
    language?: string;
    voiceStyle?: string;
  }): AttractionPreferences {
    const sanitized: AttractionPreferences = {};

    const themeCandidate = typeof preferences?.theme === 'string' ? preferences.theme : undefined;
    const audioLengthCandidate = preferences?.audioLength;
    const voiceStyleCandidate = typeof preferences?.voiceStyle === 'string' ? preferences.voiceStyle : undefined;
    const languageCandidate = typeof preferences?.language === 'string' ? preferences.language : undefined;

    if (themeCandidate && GeminiProvider.allowedThemes.includes(themeCandidate as AttractionTheme)) {
      sanitized.theme = themeCandidate as AttractionTheme;
    }

    if (audioLengthCandidate && GeminiProvider.allowedAudioLengths.includes(audioLengthCandidate)) {
      sanitized.audioLength = audioLengthCandidate;
    }

    if (voiceStyleCandidate) {
      sanitized.voiceStyle = voiceStyleCandidate;
    }

    if (languageCandidate && GeminiProvider.allowedLanguages.includes(languageCandidate as SupportedLanguage)) {
      sanitized.language = languageCandidate as SupportedLanguage;
    }

    return sanitized;
  }
}
